// Generated by CoffeeScript 1.3.1
var BC_ADD, BC_BITWISE_AND, BC_BITWISE_OR, BC_BITWISE_SHIFT, BC_BITWISE_XOR, BC_COMPARE_EQ, BC_COMPARE_GT, BC_COMPARE_GTEQ, BC_COMPARE_LT, BC_COMPARE_LTEQ, BC_COMPARE_NEQ, BC_DIVIDE, BC_FLOOR, BC_FLOW_BI, BC_FLOW_CALL, BC_FLOW_CALL_F, BC_FLOW_DIP, BC_FLOW_IF, BC_FLOW_RETURN, BC_FLOW_SIP, BC_FLOW_TIMES, BC_FLOW_TRI, BC_FLOW_UNTIL, BC_FLOW_WHILE, BC_GET_TYPE, BC_LENGTH, BC_MEM_COLLECT, BC_MEM_COPY, BC_MEM_FETCH, BC_MEM_RELEASE, BC_MEM_REQUEST, BC_MEM_STORE, BC_MULTIPLY, BC_PUSH_C, BC_PUSH_COMMENT, BC_PUSH_F, BC_PUSH_N, BC_PUSH_S, BC_QUOTE_NAME, BC_REMAINDER, BC_REPORT_ERROR, BC_STACK_CLEAR, BC_STACK_DEPTH, BC_STACK_DROP, BC_STACK_DUP, BC_STACK_NIP, BC_STACK_OVER, BC_STACK_SWAP, BC_STACK_TUCK, BC_STRING_NUMERIC, BC_STRING_SEEK, BC_STRING_SUBSTR, BC_SUBTRACT, BC_TO_LOWER, BC_TO_UPPER, BC_TYPE_C, BC_TYPE_F, BC_TYPE_FLAG, BC_TYPE_N, BC_TYPE_S, MAX_SLICES, SLICE_LEN, TYPE_CHARACTER, TYPE_FLAG, TYPE_FUNCTION, TYPE_NUMBER, TYPE_STRING, add_definition, collect_unused_slices, compile, compile_source, copy_slice, dictionary_names, dictionary_slices, fetch, gather_references, interpret, log, lookup_pointer, p_map, p_slices, pointer_to_name, prepare, prepare_dictionary, prepare_slices, release_slice, report_error, request_slice, seek_all_references, slice_to_string, sp, stack, stack_convert_type, stack_depth, stack_dup, stack_over, stack_pop, stack_push, stack_swap, stack_tuck, store, string_to_slice, types;

MAX_SLICES = 64000;

SLICE_LEN = 1000;

if (typeof String.prototype.startsWith !== 'function') {
  String.prototype.startsWith = function(str) {
    return this.slice(0, str.length) === str;
  };
}

if (typeof String.prototype.endsWith !== 'function') {
  String.prototype.endsWith = function(str) {
    return this.slice(-str.length) === str;
  };
}

if (typeof String.prototype.trim !== 'function') {
  String.prototype.trim = function() {
    return this.replace(/^\s+|\s+$/g, '');
  };
}

Array.prototype.unique = function() {
  var key, output, value, _i, _ref, _results;
  output = {};
  for (key = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; key = 0 <= _ref ? ++_i : --_i) {
    output[this[key]] = this[key];
  }
  _results = [];
  for (key in output) {
    value = output[key];
    _results.push(value);
  }
  return _results;
};

TYPE_NUMBER = 100;

TYPE_STRING = 200;

TYPE_CHARACTER = 300;

TYPE_FUNCTION = 400;

TYPE_FLAG = 500;

BC_PUSH_N = 100;

BC_PUSH_S = 101;

BC_PUSH_C = 102;

BC_PUSH_F = 103;

BC_PUSH_COMMENT = 104;

BC_TYPE_N = 110;

BC_TYPE_S = 111;

BC_TYPE_C = 112;

BC_TYPE_F = 113;

BC_TYPE_FLAG = 114;

BC_GET_TYPE = 120;

BC_ADD = 200;

BC_SUBTRACT = 201;

BC_MULTIPLY = 202;

BC_DIVIDE = 203;

BC_REMAINDER = 204;

BC_FLOOR = 205;

BC_BITWISE_SHIFT = 210;

BC_BITWISE_AND = 211;

BC_BITWISE_OR = 212;

BC_BITWISE_XOR = 213;

BC_COMPARE_LT = 220;

BC_COMPARE_GT = 221;

BC_COMPARE_LTEQ = 222;

BC_COMPARE_GTEQ = 223;

BC_COMPARE_EQ = 224;

BC_COMPARE_NEQ = 225;

BC_FLOW_IF = 300;

BC_FLOW_WHILE = 301;

BC_FLOW_UNTIL = 302;

BC_FLOW_TIMES = 303;

BC_FLOW_CALL = 304;

BC_FLOW_CALL_F = 305;

BC_FLOW_DIP = 306;

BC_FLOW_SIP = 307;

BC_FLOW_BI = 308;

BC_FLOW_TRI = 309;

BC_FLOW_RETURN = 399;

BC_MEM_COPY = 400;

BC_MEM_FETCH = 401;

BC_MEM_STORE = 402;

BC_MEM_REQUEST = 403;

BC_MEM_RELEASE = 404;

BC_MEM_COLLECT = 405;

BC_STACK_DUP = 500;

BC_STACK_DROP = 501;

BC_STACK_SWAP = 502;

BC_STACK_OVER = 503;

BC_STACK_TUCK = 504;

BC_STACK_NIP = 505;

BC_STACK_DEPTH = 506;

BC_STACK_CLEAR = 507;

BC_QUOTE_NAME = 600;

BC_STRING_SEEK = 700;

BC_STRING_SUBSTR = 701;

BC_STRING_NUMERIC = 702;

BC_TO_LOWER = 800;

BC_TO_UPPER = 801;

BC_LENGTH = 802;

BC_REPORT_ERROR = 900;

log = [];

report_error = function(text) {
  return log.push(text);
};

stack = [];

types = [];

sp = 0;

stack_push = function(v, t) {
  stack[sp] = v;
  types[sp] = t;
  return sp++;
};

stack_pop = function() {
  sp--;
  return stack[sp];
};

stack_depth = function() {
  return stack_push(sp, TYPE_NUMBER);
};

stack_swap = function() {
  var ta, tb, va, vb;
  sp--;
  ta = stack[sp];
  va = types[sp];
  sp--;
  tb = stack[sp];
  vb = types[sp];
  stack_push(ta, va);
  return stack_push(tb, vb);
};

stack_dup = function() {
  var ta, tb, vb;
  if (types[sp] === TYPE_STRING) {
    tb = stack[sp - 1];
    ta = slice_to_string(tb);
    tb = string_to_slice(ta);
    return stack_push(tb, TYPE_STRING);
  } else {
    tb = stack[sp - 1];
    vb = types[sp - 1];
    return stack_push(tb, vb);
  }
};

stack_over = function() {
  var ta, va;
  ta = stack[sp - 2];
  va = types[sp - 2];
  return stack_push(ta, va);
};

stack_tuck = function() {
  var ta, va;
  stack_dup();
  ta = stack[sp - 1];
  va = types[sp - 1];
  stack_pop();
  stack_swap();
  return stack_push(ta, va);
};

stack_convert_type = function(type) {
  var s;
  if (type === TYPE_NUMBER) {
    if (types[sp - 1] === TYPE_STRING) {
      s = slice_to_string(stack[sp - 1]);
      if (!isNaN(parseFloat(s, 10)) && isFinite(s)) {
        return stack_push(parseFloat(slice_to_string(stack_pop())), TYPE_NUMBER);
      } else {
        stack_pop();
        return stack_push(0, TYPE_NUMBER);
      }
    } else {
      return types[sp - 1] = TYPE_NUMBER;
    }
  } else if (type === TYPE_STRING) {
    if (types[sp - 1] === TYPE_NUMBER) {
      return stack_push(string_to_slice(stack_pop().toString()), TYPE_STRING);
    } else if (types[sp - 1] === TYPE_CHARACTER) {
      return stack_push(string_to_slice(String.fromCharCode(stack_pop())), TYPE_STRING);
    } else if (types[sp - 1] === TYPE_FLAG) {
      s = stack_pop();
      if (s === -1) {
        return stack_push(string_to_slice('true'), TYPE_STRING);
      } else if (s === 0) {
        return stack_push(string_to_slice('false'), TYPE_STRING);
      } else {
        return stack_push(string_to_slice('malformed flag'), TYPE_STRING);
      }
    } else if (types[sp - 1] === TYPE_FUNCTION) {
      return types[sp - 1] = TYPE_STRING;
    } else {
      return 0;
    }
  } else if (type === TYPE_CHARACTER) {
    if (types[sp - 1] === TYPE_STRING) {
      s = slice_to_string(stack_pop());
      return stack_push(s.charCodeAt(0), TYPE_CHARACTER);
    } else {
      s = stack_pop();
      return stack_push(parseFloat(s), TYPE_CHARACTER);
    }
  } else if (type === TYPE_FUNCTION) {
    return types[sp - 1] = TYPE_FUNCTION;
  } else if (type === TYPE_FLAG) {
    if (types[sp - 1] === TYPE_STRING) {
      s = slice_to_string(stack_pop());
      if (s === 'true') {
        return stack_push(-1, TYPE_FLAG);
      } else if (s === 'false') {
        return stack_push(0, TYPE_FLAG);
      } else {
        return stack_push(1, TYPE_FLAG);
      }
    } else {
      s = stack_pop();
      return stack_push(s, TYPE_FLAG);
    }
  } else {

  }
};

p_slices = [];

p_map = [];

copy_slice = function(source, dest) {
  var i, v, _results;
  i = 0;
  _results = [];
  while (i < SLICE_LEN) {
    v = fetch(source, i);
    store(v, dest, i);
    _results.push(i++);
  }
  return _results;
};

request_slice = function() {
  var i;
  i = 0;
  while (i < MAX_SLICES) {
    if (p_map[i] === 0) {
      p_map[i] = 1;
      return i;
    }
    i++;
  }
  return -1;
};

release_slice = function(s) {
  return p_map[s] = 0;
};

prepare_slices = function() {
  var i, _results;
  i = 0;
  _results = [];
  while (i < MAX_SLICES) {
    p_slices[i] = [];
    p_map[i] = 0;
    _results.push(i++);
  }
  return _results;
};

store = function(v, s, o) {
  return p_slices[s][o] = v;
};

fetch = function(s, o) {
  return p_slices[s][o];
};

gather_references = function(s) {
  var i, p, refs;
  refs = [];
  i = 0;
  while (i < SLICE_LEN) {
    p = fetch(s, i);
    if (p >= 0) {
      if (refs.indexOf(p) === -1) {
        refs.push(p);
      }
    }
    i++;
  }
  refs.push(s);
  return refs;
};

seek_all_references = function() {
  var k, maybe, s, _i, _j, _len, _len1, _ref;
  maybe = [];
  for (_i = 0, _len = dictionary_slices.length; _i < _len; _i++) {
    s = dictionary_slices[_i];
    _ref = gather_references(s);
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      k = _ref[_j];
      if (maybe.indexOf(k) === -1) {
        maybe.push(k);
      }
    }
  }
  return maybe;
};

collect_unused_slices = function() {
  var i, refs, _results;
  refs = seek_all_references().sort();
  i = 0;
  _results = [];
  while (i < MAX_SLICES) {
    if ((p_map[i] === 1) && (refs.indexOf(i) === -1)) {
      release_slice(i);
    }
    _results.push(i++);
  }
  return _results;
};

compile = function(src, s) {
  var f, i, m, offset, old, quotes, slice;
  src = src.replace(/(\r\n|\n|\r)/gm, " ");
  src = src.replace(/\s+/g, " ");
  src = src.split(" ");
  slice = s;
  quotes = [];
  i = 0;
  offset = 0;
  while (i < src.length) {
    if (src[i] === '[') {
      quotes.push(slice);
      quotes.push(offset);
      offset = 0;
      slice = request_slice();
    } else if (src[i] === ']') {
      old = slice;
      store(BC_FLOW_RETURN, slice, offset);
      offset = quotes.pop();
      slice = quotes.pop();
      store(BC_PUSH_F, slice, offset);
      offset++;
      store(old, slice, offset);
      offset++;
    } else if (src[i].startsWith('`')) {
      store(parseFloat(src[i].substring(1)), slice, offset);
      offset++;
    } else if (src[i].startsWith('#')) {
      store(BC_PUSH_N, slice, offset);
      offset++;
      store(parseFloat(src[i].substring(1)), slice, offset);
      offset++;
    } else if (src[i].startsWith('$')) {
      store(BC_PUSH_C, slice, offset);
      offset++;
      store(src[i].substring(1).charCodeAt(0), slice, offset);
      offset++;
    } else if (src[i].startsWith('&')) {
      store(BC_PUSH_F, slice, offset);
      offset++;
      if (lookup_pointer(src[i].substring(1)) === -1) {
        store(parseFloat(src[i].substring(1)), slice, offset);
      } else {
        store(lookup_pointer(src[i].substring(1)), slice, offset);
      }
      offset++;
    } else if (src[i].startsWith("'")) {
      if (src[i].endsWith("'")) {
        s = src[i];
      } else {
        s = src[i];
        f = 0;
        while (f === 0) {
          i = i + 1;
          if (src[i].endsWith("'")) {
            s += " " + src[i];
            f = 1;
          } else {
            s += " " + src[i];
          }
        }
      }
      store(BC_PUSH_S, slice, offset);
      offset++;
      s = s.slice(1, (s.length - 2) + 1 || 9e9);
      m = string_to_slice(s);
      store(m, slice, offset);
      offset++;
    } else if (src[i].startsWith('"')) {
      if (src[i].endsWith('"')) {
        s = src[i];
      } else {
        s = src[i];
        f = 0;
        while (f === 0) {
          i = i + 1;
          if (src[i].endsWith('"')) {
            s += " " + src[i];
            f = 1;
          } else {
            s += " " + src[i];
          }
        }
      }
      store(BC_PUSH_COMMENT, slice, offset);
      offset++;
      s = s.slice(1, (s.length - 2) + 1 || 9e9);
      m = string_to_slice(s);
      store(m, slice, offset);
      offset++;
    } else {
      if (lookup_pointer(src[i]) === -1) {
        report_error(src[i] + ' not found in dictionary');
      } else {
        store(BC_FLOW_CALL, slice, offset);
        offset++;
        store(lookup_pointer(src[i]), slice, offset);
        offset++;
      }
    }
    i++;
  }
  store(BC_FLOW_RETURN, slice, offset);
  return slice;
};

dictionary_names = [];

dictionary_slices = [];

add_definition = function(name, ptr) {
  if (lookup_pointer(name) === -1) {
    dictionary_names.push(name);
    dictionary_slices.push(ptr);
  } else {
    copy_slice(ptr, lookup_pointer(name));
  }
  return 0;
};

lookup_pointer = function(name) {
  var found, index;
  index = 0;
  found = -1;
  name = name.toLowerCase();
  while (index < dictionary_names.length) {
    if (dictionary_names[index].toLowerCase() === name) {
      found = index;
      index = dictionary_names.length;
    }
    index++;
  }
  if (found === -1) {
    return -1;
  } else {
    return dictionary_slices[found];
  }
};

pointer_to_name = function(ptr) {
  var i, s;
  i = 0;
  s = '';
  while (i < dictionary_names.length) {
    if (dictionary_slices[i] === ptr) {
      s = dictionary_names[i];
    }
    i++;
  }
  return s;
};

prepare_dictionary = function() {
  var s;
  s = request_slice();
  store(BC_QUOTE_NAME, s, 0);
  store(BC_FLOW_RETURN, s, 1);
  return add_definition('define', s);
};

string_to_slice = function(str) {
  var i, slice;
  slice = request_slice();
  i = 0;
  while (i < str.length) {
    if (str.charCodeAt(i) === '\n') {
      store(92, slice, i);
      i = i + 1;
      store(110, slice, i);
    } else {
      store(str.charCodeAt(i), slice, i);
    }
    i = i + 1;
  }
  store(0, slice, i);
  return slice;
};

slice_to_string = function(slice) {
  var o, s;
  s = "";
  o = 0;
  while (fetch(slice, o) !== 0) {
    s = s + String.fromCharCode(fetch(slice, o));
    o++;
  }
  s.replace(/\\n/g, '\n');
  return s;
};

interpret = function(slice) {
  var a, b, c, dest, f, len, name, offset, opcode, q1, q2, q3, qf, qt, quote, s, s0, s1, source, start, ta, target, tb, va, value, vb, vd, vt;
  offset = 0;
  while (offset < SLICE_LEN) {
    opcode = fetch(slice, offset);
    if (opcode === BC_PUSH_N) {
      offset++;
      value = fetch(slice, offset);
      stack_push(value, TYPE_NUMBER);
    }
    if (opcode === BC_PUSH_S) {
      offset++;
      value = fetch(slice, offset);
      stack_push(value, TYPE_STRING);
    }
    if (opcode === BC_PUSH_C) {
      offset++;
      value = fetch(slice, offset);
      stack_push(value, TYPE_CHARACTER);
    }
    if (opcode === BC_PUSH_F) {
      offset++;
      value = fetch(slice, offset);
      stack_push(value, TYPE_FUNCTION);
    }
    if (opcode === BC_PUSH_COMMENT) {
      offset++;
      value = fetch(slice, offset);
    }
    if (opcode === BC_TYPE_N) {
      stack_convert_type(TYPE_NUMBER);
    }
    if (opcode === BC_TYPE_S) {
      stack_convert_type(TYPE_STRING);
    }
    if (opcode === BC_TYPE_C) {
      stack_convert_type(TYPE_CHARACTER);
    }
    if (opcode === BC_TYPE_F) {
      stack_convert_type(TYPE_FUNCTION);
    }
    if (opcode === BC_TYPE_FLAG) {
      stack_convert_type(TYPE_FLAG);
    }
    if (opcode === BC_GET_TYPE) {
      stack_push(types[sp - 1], TYPE_NUMBER);
    }
    if (opcode === BC_ADD) {
      ta = types[sp - 1];
      tb = types[sp - 2];
      va = stack_pop();
      vb = stack_pop();
      if (ta === tb && ta === TYPE_STRING) {
        va = slice_to_string(va);
        vb = slice_to_string(vb);
        stack_push(string_to_slice(vb + va), TYPE_STRING);
      } else {
        stack_push(vb + va, TYPE_NUMBER);
      }
    }
    if (opcode === BC_SUBTRACT) {
      a = stack_pop();
      b = stack_pop();
      stack_push(b - a, TYPE_NUMBER);
    }
    if (opcode === BC_MULTIPLY) {
      a = stack_pop();
      b = stack_pop();
      stack_push(b * a, TYPE_NUMBER);
    }
    if (opcode === BC_DIVIDE) {
      a = stack_pop();
      b = stack_pop();
      stack_push(b / a, TYPE_NUMBER);
    }
    if (opcode === BC_REMAINDER) {
      a = stack_pop();
      b = stack_pop();
      stack_push(b % a, TYPE_NUMBER);
    }
    if (opcode === BC_FLOOR) {
      stack_push(Math.floor(stack_pop()), TYPE_NUMBER);
    }
    if (opcode === BC_BITWISE_SHIFT) {
      a = stack_pop();
      b = stack_pop();
      if (a < 0) {
        stack_push(b << Math.abs(a), TYPE_NUMBER);
      } else {
        stack_push(b >>= a, TYPE_NUMBER);
      }
    }
    if (opcode === BC_BITWISE_AND) {
      a = stack_pop();
      b = stack_pop();
      stack_push(a & b, TYPE_NUMBER);
    }
    if (opcode === BC_BITWISE_OR) {
      a = stack_pop();
      b = stack_pop();
      stack_push(a | b, TYPE_NUMBER);
    }
    if (opcode === BC_BITWISE_XOR) {
      a = stack_pop();
      b = stack_pop();
      stack_push(a ^ b, TYPE_NUMBER);
    }
    if (opcode === BC_COMPARE_LT) {
      a = stack_pop();
      b = stack_pop();
      if (b < a) {
        stack_push(-1, TYPE_FLAG);
      } else {
        stack_push(0, TYPE_FLAG);
      }
    }
    if (opcode === BC_COMPARE_GT) {
      a = stack_pop();
      b = stack_pop();
      if (b > a) {
        stack_push(-1, TYPE_FLAG);
      } else {
        stack_push(0, TYPE_FLAG);
      }
    }
    if (opcode === BC_COMPARE_LTEQ) {
      a = stack_pop();
      b = stack_pop();
      if (b === a || b < a) {
        stack_push(-1, TYPE_FLAG);
      } else {
        stack_push(0, TYPE_FLAG);
      }
    }
    if (opcode === BC_COMPARE_GTEQ) {
      a = stack_pop();
      b = stack_pop();
      if (b === a || b > a) {
        stack_push(-1, TYPE_FLAG);
      } else {
        stack_push(0, TYPE_FLAG);
      }
    }
    if (opcode === BC_COMPARE_EQ) {
      ta = types[sp - 1];
      tb = types[sp - 2];
      va = stack_pop();
      vb = stack_pop();
      if ((ta === TYPE_STRING) && (tb === TYPE_STRING)) {
        va = slice_to_string(va);
        vb = slice_to_string(vb);
      }
      if (va === vb) {
        stack_push(-1, TYPE_FLAG);
      } else {
        stack_push(0, TYPE_FLAG);
      }
    }
    if (opcode === BC_COMPARE_NEQ) {
      ta = types[sp - 1];
      tb = types[sp - 2];
      va = stack_pop();
      vb = stack_pop();
      if ((ta === TYPE_STRING) && (tb === TYPE_STRING)) {
        va = slice_to_string(va);
        vb = slice_to_string(vb);
      }
      if (va !== vb) {
        stack_push(-1, TYPE_FLAG);
      } else {
        stack_push(0, TYPE_FLAG);
      }
    }
    if (opcode === BC_FLOW_IF) {
      qf = stack_pop();
      qt = stack_pop();
      f = stack_pop();
      if (f === -1) {
        interpret(qt);
      } else {
        interpret(qf);
      }
    }
    if (opcode === BC_FLOW_WHILE) {
      qt = stack_pop();
      f = -1;
      while (f === -1) {
        interpret(qt);
        f = stack_pop();
      }
    }
    if (opcode === BC_FLOW_UNTIL) {
      qt = stack_pop();
      f = 0;
      while (f === 0) {
        interpret(qt);
        f = stack_pop();
      }
    }
    if (opcode === BC_FLOW_TIMES) {
      qt = stack_pop();
      f = stack_pop();
      while ((f--) > 0) {
        interpret(qt);
      }
    }
    if (opcode === BC_FLOW_CALL) {
      offset++;
      target = fetch(slice, offset);
      interpret(target);
    }
    if (opcode === BC_FLOW_CALL_F) {
      target = stack_pop();
      interpret(target);
    }
    if (opcode === BC_FLOW_DIP) {
      target = stack_pop();
      vt = types[sp - 1];
      vd = stack_pop();
      interpret(target);
      stack_push(vd, vt);
    }
    if (opcode === BC_FLOW_SIP) {
      target = stack_pop();
      stack_dup();
      vt = types[sp - 1];
      vd = stack_pop();
      interpret(target);
      stack_push(vd, vt);
    }
    if (opcode === BC_FLOW_BI) {
      q1 = stack_pop();
      q2 = stack_pop();
      stack_dup();
      vt = types[sp - 1];
      vd = stack_pop();
      interpret(q2);
      stack_push(vd, vt);
      interpret(q1);
    }
    if (opcode === BC_FLOW_TRI) {
      q1 = stack_pop();
      q2 = stack_pop();
      q3 = stack_pop();
      stack_dup();
      vt = types[sp - 1];
      vd = stack_pop();
      interpret(q3);
      stack_push(vd, vt);
      interpret(q2);
      stack_push(vd, vt);
      interpret(q1);
    }
    if (opcode === BC_FLOW_RETURN) {
      offset = SLICE_LEN;
    }
    if (opcode === BC_MEM_COPY) {
      dest = stack_pop();
      source = stack_pop();
      copy_slice(source, dest);
    }
    if (opcode === BC_MEM_FETCH) {
      a = stack_pop();
      b = stack_pop();
      stack_push(fetch(b, a), TYPE_NUMBER);
    }
    if (opcode === BC_MEM_STORE) {
      a = stack_pop();
      b = stack_pop();
      c = stack_pop();
      store(c, b, a);
    }
    if (opcode === BC_MEM_REQUEST) {
      stack_push(request_slice(), TYPE_FUNCTION);
    }
    if (opcode === BC_MEM_RELEASE) {
      release_slice(stack_pop());
    }
    if (opcode === BC_MEM_COLLECT) {
      collect_unused_slices();
    }
    if (opcode === BC_STACK_DUP) {
      stack_dup();
    }
    if (opcode === BC_STACK_DROP) {
      stack_pop();
    }
    if (opcode === BC_STACK_SWAP) {
      stack_swap();
    }
    if (opcode === BC_STACK_OVER) {
      stack_over();
    }
    if (opcode === BC_STACK_TUCK) {
      stack_tuck();
    }
    if (opcode === BC_STACK_NIP) {
      stack_swap();
      stack_pop();
    }
    if (opcode === BC_STACK_DEPTH) {
      stack_depth();
    }
    if (opcode === BC_STACK_CLEAR) {
      sp = 0;
    }
    if (opcode === BC_QUOTE_NAME) {
      value = stack_pop();
      quote = stack_pop();
      name = slice_to_string(value);
      add_definition(name, quote);
    }
    if (opcode === BC_STRING_SEEK) {
      a = slice_to_string(stack_pop());
      b = slice_to_string(stack_pop());
      stack_push(b.indexOf(a), TYPE_NUMBER);
    }
    if (opcode === BC_STRING_SUBSTR) {
      len = stack_pop();
      start = stack_pop();
      s0 = slice_to_string(stack_pop());
      s1 = s0.substr(start, len);
      stack_push(string_to_slice(s1), TYPE_STRING);
    }
    if (opcode === BC_STRING_NUMERIC) {
      s = stack_pop();
      s = slice_to_string(s);
      if (!isNaN(parseFloat(s, 10)) && isFinite(s)) {
        stack_push(-1, TYPE_FLAG);
      } else {
        stack_push(0, TYPE_FLAG);
      }
    }
    if (opcode === BC_TO_LOWER) {
      if (types[sp - 1] === TYPE_STRING) {
        a = slice_to_string(stack_pop());
        stack_push(string_to_slice(a.toLowerCase()), TYPE_STRING);
      }
      if (types[sp - 1] === TYPE_CHARACTER) {
        a = String.fromCharCode(stack_pop());
        b = a.toLowerCase();
        stack_push(b.charCodeAt(0), TYPE_CHARACTER);
      }
    }
    if (opcode === BC_TO_UPPER) {
      if (types[sp - 1] === TYPE_STRING) {
        a = slice_to_string(stack_pop());
        stack_push(string_to_slice(a.toUpperCase()), TYPE_STRING);
      }
      if (types[sp - 1] === TYPE_CHARACTER) {
        a = String.fromCharCode(stack_pop());
        b = a.toUpperCase();
        stack_push(b.charCodeAt(0), TYPE_CHARACTER);
      }
    }
    if (opcode === BC_LENGTH) {
      f = slice_to_string(stack[sp - 1]);
      stack_push(f.length, TYPE_NUMBER);
    }
    if (opcode === BC_REPORT_ERROR) {
      report_error(slice_to_string(stack_pop()));
    }
    offset++;
  }
  return 0;
};

prepare = function() {
  prepare_slices();
  return prepare_dictionary();
};

compile_source = function(array) {
  var i, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = array.length; _i < _len; _i++) {
    i = array[_i];
    if (i.length > 0) {
      _results.push(interpret(compile(i.trim(), request_slice())));
    } else {
      _results.push(void 0);
    }
  }
  return _results;
};
